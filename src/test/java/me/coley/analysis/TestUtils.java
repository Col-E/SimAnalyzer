package me.coley.analysis;

import me.coley.analysis.value.AbstractValue;
import me.coley.analysis.value.VirtualValue;
import org.junit.jupiter.api.Assertions;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.analysis.AnalyzerException;
import org.objectweb.asm.tree.analysis.Frame;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.net.URLDecoder;
import java.nio.file.Files;

/**
 * Some common utilities.
 */
public class TestUtils {
	/**
	 * Verify the generated method.
	 *
	 * @param owner
	 * 		Name of method's defining class.
	 * @param generated
	 * 		Method generated by this assembler.
	 *
	 * @return Analyzed frames of the method.
	 *
	 * @throws AnalyzerException
	 * 		When analysis fails.
	 */
	public static Frame<AbstractValue>[] getFrames(String owner, MethodNode generated) throws AnalyzerException {
		return new SimAnalyzer(new SimInterpreter()).analyze(owner, generated);
	}

	/**
	 * @param path
	 * 		Path to class in test resources.
	 *
	 * @return Class node.
	 */
	public static ClassNode getFromName(String path) {
		try {
			ClassReader cr = new ClassReader(Files.readAllBytes(getClasspathFile(path).toPath()));
			ClassNode node = new ClassNode();
			cr.accept(node, ClassReader.SKIP_FRAMES);
			return node;
		} catch(IOException ex) {
			Assertions.fail(ex);
			throw new IllegalStateException();
		}
	}

	/**
	 * Setup type lookups / parent checking.
	 */
	public static void setupVirtualLookups() {
		VirtualValue.setParentCheck((parent, child) -> {
			try {
				Class<?> clsParent = Class.forName(parent.getClassName(), false,
						ClassLoader.getSystemClassLoader());
				Class<?> clsChild = Class.forName(child.getClassName(), false,
						ClassLoader.getSystemClassLoader());
				return clsParent.isAssignableFrom(clsChild);
			} catch(Throwable t) {
				t.printStackTrace();
				Assertions.fail(t);
				return false;
			}
		});
	}

	/**
	 * Fetch a method by its name.
	 *
	 * @param node
	 * 		Class node.
	 * @param name
	 * 		Name of method.
	 *
	 * @return Method node inclass.
	 */
	public static MethodNode getMethod(ClassNode node, String name) {
		for(MethodNode mn : node.methods)
			if (mn.name.endsWith(name))
				return mn;
		Assertions.fail("No method by name '" + name + "' in class: " + node.name);
		throw new IllegalStateException();
	}

	/**
	 * @param file
	 * 		Path to file in classpath.
	 *
	 * @return File reference.
	 *
	 * @throws IOException
	 * 		Thrown if the URL to the file could not be created.
	 */
	public static File getClasspathFile(String file) throws IOException {
		return new File(URLDecoder.decode(getClasspathUrl(file).getFile(), "UTF-8"));
	}

	/**
	 * @param file
	 * 		Path to file in classpath.
	 *
	 * @return URL reference.
	 */
	public static URL getClasspathUrl(String file) {
		ClassLoader classLoader = TestUtils.class.getClassLoader();
		return classLoader.getResource(file);
	}
}
